cTESTCOMMAND: mppl
c Test if statements
c source form
c
      subroutine foo
cProlog

c some parameter
c%%%%%-included-file:../lang4.i 
      integer nmax
      parameter(nmax=249)

c delimits current token in str
      integer i,j,
c length of str
     &  lstr,
c type of current token
     &  tok,
c value of integer token
     &  term,
c value of expression
     &  total

      integer a, b, c

c This is an explicit continue, since / is not a 'magic' continuation character
c data
      data lll1 /
c first line
     &  0,1,2,3,
c second line
     &  4,5,6,7/

      data lll2 / 0,1,2,3, 4,5,6,7/

c test long lines

      if (cat) dog = cat(10)

c comment 0
      if (cat ) dog = cat

      dog = cat(10,20,30,40,50,60,70,80,90,00,10,20,30,40,50,60,70,80,90
     &   ,100,110,0)

      if (cat) then
         dog = cat(10,20,30,40,50,60,70,80,90,00,10,20,30,40,50,60,70,80
     &      ,90,100,110,0)
      endif

      if (cat1) then
         dog = 1
      elseif (cat2) then
         dog = 2
      elseif (cat3) then
         dog = 3
      elseif (cat4) then
         dog = 4
      elseif (cat5) then
         dog = 5
      else
         dog = 6
      endif

      if (cat1) then
c comment 1
         return
      elseif (cat2) then
c comment 2
         return
      elseif (cat3) then
c comment 3
         return
      elseif (cat4) then
c comment 4
         return
c comment 5
      elseif (cat5)
     &    then
c comment 5a
         return
c comment 6
      else
         return
      endif
c comment 7

c comment 8
      if (monkey)
     &   monkey = 4

c comment 9
      if (monkey)
     & then
c comment 10
         monkey = 4
      endif

c long comment
c comment with long text blah blah blah blah blah blah blah
      if (dog)
     &   dog = 1
c comment fee fi foo fum, more and more and more
      if (bird) bird = 1

c short comment
c comment
      if (dog2)
     &   dog2 = 1
c comment
      if (bird2) bird2 = 1

      if (cat) return

c This line must be continued for f77
      if ( ns .eq. 0 .or. ns .eq. 1 .and. ss (2, rlinkp + 1) .eq. 0) 
     &      return

      if (a123456789012345678901234567890 .eq. 
     &   a123456789012345678901234567890) then
         call baserror( 
     &      "ERROR: increment field on assignment target is illegal abcd
     &efghijklmnopqrstuvwxyz")
         call baserror( 
     &      'ERROR: increment field on assignment target is illegal abcd
     &efghijklmnopqrstuvwxyz')
      endif

      a = 1 + 2 + 3 + 4 + 5 + 6 + 7 - a - b * x

      if (token1 .or. token2 .or.token3 ) then
         return
      endif

      if ((tt .eq. 1 .and. tt .ne. 2) .or. (tt .lt. 3 .and. tt .le. 4) 
     &   .or. (tt .gt. 5 .and. tt .ge. 6.0) ) then
         return
      endif

      if ((uu .ne. 1 .and. uu .ne. 2 .and. uu .ne. 3) .or. (uu .eq. 4 
     &   .and. uu .eq. 5) .or. (uu .lt. 6 .and. uu .le. 7) .or. (uu .gt.
     &    8 .and. uu .ge. 9) ) then
         return
      endif

      call cnstal('for',c//'+***short***012345+'//
     &   '+***long****abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWX
     &YZ01234567890')

      if (bpnew .gt. BUFSIZ) call oops('Macro processor error in pbstr:'
     &      // ' too many characters pushed back'// 
     &      ' abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz')

      if (bpnew .gt. BUFSIZ) call oops('Macro processor error in pbstr:'
     &      // ' too many characters pushed back'// 
     &      ' abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz')

      if (bpnew .gt. BUFSIZ) call oops('Macro processor error in pbstr:'
     &      // ' too many characters pushed back'// 
     &      ' abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz')


c Using 4 character indenting, this string will end at col 72.
c In f90 mode, the continuation characters get put beyond that
c23456789012345678901234567890123456789012345678901234567890123456789012
      call ezcremrk(
     &   "Contour plot data does not have an acceptable shape.123412341"
     &   )

c make sure numbers are treated as a single token to avoid splitting over lines
      if (t .lt. 1.) then
         val = 1. + t*(3.5156229 + t*(3.0899424 + t*(1.2067492 + t*(
     &      .2659732 + t*(.0360768 + t*.0045813)))))
      else
         val = .39894228 + t*(.01328592 + t*(.00225319 + t*(-.00157565 + 
     &      t*(.00916281 + t*(-.02057706 + t*(.02635537 + t*(-.01647633 
     &      + t*.00392377)))))))
      endif

c Treat // as a single token
      if (pfbdebug .gt. 0) then
         f(5:)=" files in glued family "// fn1(1:utgetcl(fn1))  //" - "
     &      //fn2
      endif

c Process statements after ; in main loop so keywords will be expanded
      xlog = .false.
      if (scalea(1:3) .eq. "log") xlog = .true.

c Do not end a line with a semicolon and white space
      a12345678 = a1234567890 + a1234567890 + a1234567890 + a1234567890
      b = b1234567890

      a = a1234567890 + a1234567890 + a1234567890 + a1234567890
      b = b1234567890

c Test real number tokenizing.
c nextline.l parses most real numbers, but gettok must also parse them
c since they may be pushed back into macros and re-tokenized.
c The most significant part of this test is the number on the end.
c It must not be split across lines.



      external ismaxa
c23456789012345678901234567890123456789012345678901234567890123456789012
      ismaxa(12345.67890, 12345.67890, 12345.67890, 12345.67890, 
     &   12345.67890)
      ismaxa(12345.67890, 12345.67890, 12345.67890, 12345.67890, 
     &   .1234567890)
      ismaxa(12345., 12345.67890, 12345.67890, 12345.67890, 
     &   12345.67890e00)
      ismaxa(12345., 12345.67890, 12345.67890, 12345.67890, 
     &   12345.67890e+00)

c The last .ne. is split over a line since mppl recognizes it as
c  5. ne.  instead of 5 .ne.
c This is a problem with parsing fortran in general.
      if (1.ne.nnn .and. 2.ne.nnn .and. 3.ne.nnn .and. 4.ne.nnn .and. 5
     &   .ne.nnn) then
         foo = 1
      endif


  100 format(a8)
  200 format(a8)

      end


      function bar
cProlog

      if (cat) then
         bar = x
         return
      endif

      if (cat2) then
         bar = x
         return
      endif

c comment bar1
      if (cat3)
     & then
         bar = x
         return
      endif

c comment bar2
      if (cat4)
     & then
c comment bar3
         bar = x
         return
      endif

      if (cat5) then
c bar4
         bar = x
         return
      endif

      bar = x
      if (dog) return

      if (x) then
         bar = a123456789 + b123456789 + c123456789 + d123456789 + 
     &      e123456789 + f123456789
         return
      endif

      bar = a123456789 + b123456789 + c123456789 + d123456789 + 
     &   e123456789 + f123456789
      return

c Test trailing blanks, to avoid a blank continued line
      bar = aaaaaaa*2/((((bbbbbbb*x+ccccccc)*x+ddddd)*x+eeeee)*x+ffff)
      return

      end

